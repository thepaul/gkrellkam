#!/usr/bin/perl
#
# krellkam_load - rotates a list of images and URLs
#
# VERSION - 0.3.2
#
# Copyright (C) 2001 paul cannon
# space software lab/utah state university
# paul@cannon.cs.usu.edu
# Released under the GNU Public License (GPL)
#
# requires GNU wget for URL loads-
#   see http://www.gnu.org/software/wget/wget.html

use Fcntl ':flock';

sub usage() {
  print <<'US_END';
krellkam_load 0.3.0 (Used with the GKrellKam plugin)

USAGE:

krellkam_load [options] [override]

If no command line parameters are given, krellkam_load examines the first
line of the file ~/.krellkam.list, and rotates it to the bottom. The line
can be a URL or a local path to an image file. The image is downloaded if
appropriate, and the location given to GKrellKam.

OPTIONS:

If -r or --random is specified, then the list is not rotated. One line is
selected at random and downloaded if appropriate.

If -l <listfile> or --list <listfile> is specified, then <listfile> is
used instead of ~/.krellkam.list.

If -x <program> or --execute <program> is given, the list is disregarded,
and the program specified is simply run. Any options following this are
ignored and passed to <program>.

If a filename is given on the command line without any options (override),
then krellkam_load tries to determine whether the file is an image, a
list, or another script to run. If it's an image or a URL, the list will
be disregarded and that image used. If a list, that list will be used
instead of the default, as if -l had been given. If it's an executable,
it will be run as if -x were specified, and all subsequent command line
arguments are passed to it.

US_END
  exit 0;
}

$list = $ENV{'HOME'}.'/.krellkam.list';
$cachedir = $ENV{'HOME'}.'/.gkrellm/data/gkrellkam';
$wget = 'wget';
$wgetopts = '--cache=off --proxy=off';
$exec_prog = '';
$thispic = '';
$pick_rand = 0;

sub isurl {
  my $name = shift;
  return ($name =~ /[a-z]*:\/\//i);
}

sub isalist {
  my $name = shift;
  my $thisline = '';

  return 0 if isurl ($name);
  return 0 if ($name =~ /.(jpg|jpeg|png|xpm|bmp|gif)$/i);
  return 1 if ($name =~ /.list$/i);

  open (CHECKIT, "<$name") or return 0;

  # check only the first 5 'lines' of a file to see if it's a list- lazy.
  for (1..5) {
    defined ($thisline = <CHECKIT>) || return 1;

    # assume that local filenames in lists are absolute pathnames. Err
    # on the side of images, since if you have a list, you can force
    # treating it as a list with -l on the command line..
    unless (isurl ($thisline) || $thisline =~ /^\/[[:print:]]*$/) {
      close CHECKIT;
      return 0;
    }
  }
  close CHECKIT;
  return 1;
}

sub checkargs {
  do_args: while (@_) {
    $_ = shift;

    # if we're running another script, give it the options
    if ($exec_prog) {
      $exec_prog .= (" " . $_);
      next do_args;
    }

    (/^-r$/ || /^--random$/) && do {
      $pick_rand = 1;
      next do_args;
    };
    (/^-l$/ || /^--list$/) && do {      
      $list = shift;
      next do_args;
    };
    (/^-x$/ || /^--execute$/) && do {
      $exec_prog = shift;
      next do_args;
    };
    (/^-h$/ || /^--help$/) && do {
      usage;
    };

    if (-x $_) {
      $exec_prog = $_;
    } elsif (isalist ($_)) {
      $list = $_;
    } else {
      $thispic = $_;
    }
  }
}
    
sub lockfile {
  my $file = shift;
  flock ($file, LOCK_EX);
}

sub unlockfile {
  my $file = shift;
  flock ($file, LOCK_UN);
}

checkargs (@ARGV);

if ($exec_prog) {
  exec ($exec_prog);   # won't return..
}

if ($thispic eq "") {

  # open the list
  die "Can't open listfile $list" unless open (LISTFILE, "+<$list");
  lockfile (*LISTFILE);
  seek (LISTFILE, 0, 0);

  @fnames = <LISTFILE>;
  die "Listfile $list is empty" unless ($#fnames > -1);

  if ($pick_rand) {
    srand (time ^ ($$ + ($$ << 15)));   # for old Perls
    $thispic = $fnames[rand ($#fnames + 1)];
  } else {
    # rotate the list
    seek (LISTFILE, 0, 0);

    print LISTFILE (join '', @fnames[1..$#fnames]);
    print LISTFILE $fnames[0];
    $thispic = $fnames[0];
  }
  unlockfile (*LISTFILE);
  close LISTFILE;
}

$thispic =~ s/\n*$//;       # remove newlines at end

if (isurl ($thispic)) {

  # Load URL. First convert it to a name suitable for a filename..
  ($localname = $thispic) =~ tr[:/%!\\"`'$*?&=]/-/;

  # Make sure a directory is where we want it..
  mkdir $cachedir,0777;

  # download.
  $cmdstr = "$wget -q $wgetopts -O \"$cachedir/$localname\" $thispic";
  (system ($cmdstr) != -1) or die "Couldn't run $cmdstr";
  print "$cachedir/$localname\n";

} else {

  # Local image file..
  print "$thispic\n";

}
